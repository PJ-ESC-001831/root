#!/bin/bash

# Function to commit and push changes to Git
commit_and_push() {
  if [ -z "$1" ]; then
    echo "What is the conventional type? Default is 'feat':"
    read commit_type

    if [ -z "$commit_type" ]; then
      commit_type="feat"
    fi

    case $commit_type in
      feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)
        ;;
      *)
        echo "Invalid type. Choose from (feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)."
        return 1
        ;;
    esac

    echo "Please enter a commit message:"
    read commit_message
  else
    commit_message="$1"
    echo "What is the conventional type? Default is 'feat':"
    read commit_type

    if [ -z "$commit_type" ]; then
      commit_type="feat"
    fi

    case $commit_type in
      feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)
        ;;
      *)
        echo "Invalid type. Choose from (feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)."
        return 1
        ;;
    esac
  fi

  if [ -z "$commit_message" ]; then
    echo "Commit message is required. Exiting."
    return 1
  fi

  final_commit_message="$commit_type: $commit_message"

  # Function to commit and push changes in the current directory
  commit_push_current_dir() {
    local message="$1"
    git add . && git commit -m "$message"

    # Check if commit was successful
    if [ $? -ne 0 ]; then
      echo "Commit failed. Please check for errors."
      return 1
    fi

    git push

    # Check if push was successful
    if [ $? -ne 0 ]; then
      echo "Push failed. Please check for errors."
      return 1
    fi

    echo "Changes committed and pushed successfully in $(pwd)."
  }

  original_dir=$(pwd)
  dir_stack=()

  # Recursively commit and push changes up to the root
  while true; do
    commit_push_current_dir "$final_commit_message"
    superproject_dir=$(git rev-parse --show-superproject-working-tree)
    if [ -z "$superproject_dir" ]; then
      break
    fi
    dir_stack+=("$superproject_dir")
    cd "$superproject_dir"
  done

  # Walk back down to the original directory
  for dir in "${dir_stack[@]}"; do
    cd "$dir"
    if [ "$dir" == "$original_dir" ]; then
      # Get the relative path of the sub-module
      relative_path=$(realpath --relative-to="$(git rev-parse --show-toplevel)" "$dir")
      submodule_name=$(basename "$relative_path")
      commit_push_current_dir "sync: updated ${submodule_name} sub-module"
    else
      commit_push_current_dir "$final_commit_message"
    fi
  done

  cd "$original_dir"
}

# Alias for easily committing across submodules
alias cap=commit_and_push

# NPM shortcuts
alias ni="npm install"
alias nd="npm install -D"
alias generate="npm --prefix /workspace/api/src/database/ run drizzle-kit:generate"
alias migrate="npm --prefix /workspace/api/src/database/ run drizzle-kit:migrate"

# Environment shortcuts
alias rc-sync="cp api/.devcontainer/.bashrc ~/.bashrc && source ~/.bashrc"

# Function to display aliases in a table format
display_aliases() {
  echo -e "\nLoaded Aliases:"
  echo -e "----------------------------------------------"
  echo -e "Alias\t\tCommand"
  echo -e "----------------------------------------------"
  alias | awk -F'[ =]' '{cmd=""; for (i=3; i<=NF; i++) cmd=cmd $i " "; printf "%-15s %s\n", $2, cmd}'
  echo -e "----------------------------------------------\n"
}

# Display the loaded aliases when the script is sourced
display_aliases
